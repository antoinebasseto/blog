[{"content":" User authentication is the first step in building any app that needs to track who\u0026rsquo;s who — like one with user credits 👀 — and with Streamlit\u0026rsquo;s new native authentication features, it\u0026rsquo;s easier than ever! This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Why User Authentication? #So, why bother with user authentication when all we want is a credit system? Well, every user needs their own balance. We need to be able to track who paid for what, and who\u0026rsquo;s using how much, and for that we first need to know who\u0026rsquo;s who. Luckily, Streamlit has made this process super easy with its native authentication features introduced in version 1.42. This means setting up secure logins will be a breeze!\nPrerequisites #Before we jump in, make sure you have the following ready:\nStreamlit version \u0026gt;= 1.42.0: The native authentication features are available from this version onward. Check your version with streamlit --version. Authlib \u0026gt;= 1.3.2: This library is required to use Streamlit\u0026rsquo;s native authentication features. Install it with pip install Authlib. Once you’ve got these sorted, you’re ready to set up authentication!\nSetting Up Native Authentication in Streamlit #Streamlit now offers a straightforward way to handle user logins. You can read more from the official docs here, but we\u0026rsquo;ll break down the process step by step.\nConfigure Your Identity Provider #Identity providers handle the heavy lifting of user authentication and security — so you don\u0026rsquo;t have to manage passwords or other sensitive details yourself. Streamlit supports any provider using OpenID Connect (OIDC), but in this tutorial we will use Google Identity. Why? Well, it\u0026rsquo;s straightforward to set up and widely used. However, this does mean users will need a Google account to sign up for our app. If that’s a problem, you can explore other providers, such as Auth0.\nLet\u0026rsquo;s walk through the process of setting up Google as your identity provider:\nSign up for Google Cloud\nFirst, you\u0026rsquo;ll need a Google Cloud account. If you don\u0026rsquo;t already have one, go to the Google Cloud Console and sign up with your Google account.\nCreate a New Project\nLook for the project dropdown near the top of the page Click \u0026ldquo;New Project\u0026rdquo; Give your project a name that\u0026rsquo;s relevant to your Streamlit app Click \u0026ldquo;Create\u0026rdquo; Wait for Google to set up your new project (it might take a minute) Make sure your new project is selected in the project dropdown Set Up OAuth Credentials\nNow we need to create OAuth credentials that your Streamlit app will use to authenticate users:\nIn the left sidebar, navigate to \u0026ldquo;APIs \u0026amp; Services \u0026gt; Credentials\u0026rdquo; Click the \u0026ldquo;Create Credentials\u0026rdquo; button at the top of the page Select \u0026ldquo;OAuth client ID\u0026rdquo; from the dropdown menu When prompted to configure the consent screen first, click \u0026ldquo;Configure Consent Screen\u0026rdquo; and fill in the required information: App name: The name users will see when signing in User support email: Your email address Select \u0026ldquo;External\u0026rdquo; as the user type (unless you\u0026rsquo;re building an internal app for a Google Workspace organization) Developer contact information: Your email address Under \u0026ldquo;Google Auth Platform / Audience\u0026rdquo;, go to \u0026ldquo;Test Users\u0026rdquo; and add the Google account you will use for testing. Under \u0026ldquo;Google Auth Platform / Data access\u0026rdquo;, click \u0026ldquo;Add or remove scopes\u0026rdquo; and select the scope .../auth/userinfo.email, which means we will have access to our users\u0026rsquo; email address, then click \u0026ldquo;Update\u0026rdquo;. Now in the left sidebar, return to \u0026ldquo;APIs \u0026amp; Services \u0026gt; Credentials\u0026rdquo; and click \u0026ldquo;Create Credentials \u0026gt; OAuth client ID\u0026rdquo; again For \u0026ldquo;Application type,\u0026rdquo; select \u0026ldquo;Web application\u0026rdquo; Fill in the required information: Name of your OAuth client, I named mine web_client_projectname. Under \u0026ldquo;Authorized JavaScript origins\u0026rdquo;, add http://localhost:8501 Under \u0026ldquo;Authorized redirect URIs\u0026rdquo;, add http://localhost:8501/oauth2callback Once we deploy our app, we will have to add our live domain to the authorized origins and redirect URIs. Click \u0026ldquo;Create Client\u0026rdquo; Copy paste your client secret and client ID, we will need them soon! You can find them again under \u0026ldquo;Google Auth Platform / Clients\u0026rdquo; and then clicking on the client you just created. The consent screen is initially in \u0026ldquo;Testing\u0026rdquo; mode with restrictions on the number of users. For a production app, you would need to go through Google\u0026rsquo;s verification process to publish it, but testing mode is sufficient for development or internal apps. We\u0026rsquo;ll worry about that when we try to deploy our app.\nConfigure Your Secrets #Now that we\u0026rsquo;re all set up on Google\u0026rsquo;s side, we need to let our Streamlit app know! To use native authentication, Streamlit expects some information in the .streamlit/secrets.toml file. Remember those client secret and client id? This is where we use them.\nMake sure never to publish your secrets (e.g., avoid committing them to GitHub). Always include secrets.toml in your .gitignore file. Read more about secrets management here. Your secrets.toml file should look like this:\n[auth] redirect_uri = \u0026#34;http://localhost:8501/oauth2callback\u0026#34; cookie_secret = \u0026#34;a-long-string-of-random-characters-you-generated\u0026#34; # You can use https://www.random.org/strings/ [auth.google] client_id = \u0026#34;xxxx\u0026#34; client_secret = \u0026#34;xxxx\u0026#34; server_metadata_url = \u0026#34;https://accounts.google.com/.well-known/openid-configuration\u0026#34; Implement the Login Flow #Next, let’s implement the login flow in your Streamlit app. We’ll use Streamlit’s native auth functions: st.login, st.logout, and st.experimental_user to manage user sessions.\nA simple example would be:\nimport streamlit as st with st.sidebar: if not st.experimental_user.is_logged_in: st.button(\u0026#34;Log in\u0026#34;, on_click=st.login, args=(\u0026#34;google\u0026#34;)) st.stop() # Stop further execution if user is not logged in. st.button(\u0026#34;Log out\u0026#34;, on_click=st.logout, args=(\u0026#34;google\u0026#34;)) # Paid features come here (after st.stop()) Testing Your Authentication Setup #After implementing the login functionality, it’s time to test it out. Run your app with streamlit run your-app.py and make sure you can log in, log out and st.experimental_user contains the expected information — you can try st.write(st.experimental_user). Remember to log in with the Google account you set as a test account during set up.\nNext Steps #With user authentication in place, we can associate an email address with each user\u0026rsquo;s credit balance. Next, we’ll look at how to connect to a database.\nWant to see an example? SimplyPlot uses a credit system for monetisation - it writes Matplotlib code for you, so you can stop troubleshooting your plots. Get updates \u0026amp; insights! Subscribe ","date":"7 March 2025","permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/setting-up-user-login/","section":"Blog Posts","summary":"User authentication is the first step in building any app that needs to track who\u0026rsquo;s who — like one with user credits 👀 — and with Streamlit\u0026rsquo;s new native authentication features, it\u0026rsquo;s easier than ever!","title":"Setting Up User Login"},{"content":" Need to store user credits securely? In this post, we’ll show you how to hook your Streamlit app up to a database — with row-level security, secret-handling best practices, and a quick table setup walkthrough. This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Why Do We Need A Database? #We need a database to keep track of user credit balances reliably. Whether adding or deducting credits, the data needs to stay consistent and accessible. Streamlit\u0026rsquo;s session_state won’t work for this, as it resets every time the app reloads. Therefore, we need a proper database to store and manage credits.\nWhich Database Should I Choose? #There are a lot of options out there, and there isn’t a one-size-fits-all solution. The ideal database depends on your specific needs—ease of setup, scalability and the available free tier are all key factors.\nIf your application only needs to store structured data like user information and credits, a relational (SQL) database is typically the best choice due to its strong consistency and structured querying capabilities. However, if your app requires flexibility (e.g., dynamic or hierarchical data structures, unstructured metadata, or document-based storage), a NoSQL database might be a better fit. Also, if you need to store large files, consider pairing your database with a dedicated file storage solution (e.g., Supabase Storage, Firebase Storage, or AWS S3). Below is a comparison of popular options:\nDatabase Type Free Tier Connector? Supabase recommended PostgreSQL Unlimited API requests, up to 50,000 monthly active users, 500 MB database size, 5 GB bandwidth, and 1 GB file storage. source SQLite Cloud SQLite 1 GB storage, up to 0.5 vCPUs, 0.5 GB RAM and 30 concurrent connections. source Firebase Firestore NoSQL Only default database, 1 GiB storage, 50000 reads / day, 20000 writes / day, 20000 deletes / day, 10 GiB data transfer / month. source MongoDB Atlas NoSQL 512 MB storage, shared RAM and vCPU. source Streamlit offers step-by-step guides to show how to connect to most of these (and others).\nFor this project, we are going to use Supabase. It offers a generous free tier, is easy to set up, and integrates seamlessly with Streamlit. We will also leverage their edge function features when integrating Stripe.\nRequirements #Before we begin, make sure you have:\nUser Login Set Up: If you haven\u0026rsquo;t done this yet, follow the first part of this series. Database Connector Installed: Install it with pip install st-supabase-connection. Connecting To A Database #Configure Your Supabase Project # Sign Up and Create a Project: Visit Supabase and sign up for a free account. Click “Create new project” and fill in: Project Name. Database Password: Choose a strong password. Region: Select the region closest to your users. Click \u0026ldquo;Create new project\u0026rdquo;. Create Your Table: In the left sidebar, click Table Editor. Click Create a new table and fill in the following: Name: Input users (or any name you prefer—just update your code accordingly). Description: Optional. Enable Row Level Security (RLS): Keep this checked. Edit Columns to include: id: Type int8 and set as the primary key. created_at: Type timestamptz with a default value of now(). email: Type text. Click the gear icon, uncheck \u0026ldquo;Is Nullable\u0026rdquo; and check \u0026ldquo;Is Unique\u0026rdquo;. credits: Type int4 (we will be storing credits as cents, the max value of an int4 number is 2147483647 i.e. a lot of money). Click the gear icon, uncheck \u0026ldquo;Is Nullable\u0026rdquo;, and set the default value to 0 (we will set a default value for new user in the code in case you do want to give new users some free credits). Click Save. Get Your Project Credentials: In the left sidebar, click Project overview. Scroll down to find your Project URL and API Key. You’ll need these soon. Set Up RLS Policies: In the left sidebar, click Authentication, then select Policies. Click Create policy and choose the template Enable insert for authenticated users only, and click Save policy. Next, select the template Enable read access for all users: Rename it to Enable read access for authenticated users only. Set the target role to authenticated. Click Save policy. Next, select again the template Enable insert for authenticated users only: Rename it to Enable update access for authenticated users only. Set the operation type to Update. Under using type true. Click Save policy. Still under Authentication, click Users in the left sidebar. Click Add user \u0026gt; Create a new user, enter an email address and a password of your choice, ensure auto confirm user is checked, then click create user. Keep these credentials handy for your connection. Configure Your Secrets #You know all this information I told you to keep handy? Well, your .streamlit/secrets.toml file is where you should put it!\nMake sure you never publish your secrets, do not commit them to GitHub! Always include secrets.toml in your .gitignore file. Read more about secrets management here. Add the following section to your secrets.toml file:\n[connections.supabase] SUPABASE_URL = \u0026#34;xxxx\u0026#34; SUPABASE_KEY = \u0026#34;xxxx\u0026#34; EMAIL_ADDRESS = \u0026#34;xxxx\u0026#34; PASSWORD = \u0026#34;xxxx\u0026#34; Connect With Your Streamlit App #Now, let\u0026rsquo;s set up the connection to the Supabase database. The code below establishes and caches a connection, ensuring that you can interact with your database securely.\n@st.cache_resource(show_spinner=False) def get_db_connection() -\u0026gt; SupabaseConnection: \u0026#34;\u0026#34;\u0026#34; Establish and cache a connection to the Supabase database. Returns: SupabaseConnection: Authenticated connection to Supabase \u0026#34;\u0026#34;\u0026#34; conn = st.connection(\u0026#34;supabase\u0026#34;, type=SupabaseConnection) conn.auth.sign_in_with_password( { \u0026#34;email\u0026#34;: st.secrets[\u0026#34;connections\u0026#34;][\u0026#34;supabase\u0026#34;][\u0026#34;EMAIL_ADDRESS\u0026#34;], \u0026#34;password\u0026#34;: st.secrets[\u0026#34;connections\u0026#34;][\u0026#34;supabase\u0026#34;][\u0026#34;PASSWORD\u0026#34;], } ) return conn Create Users As They Connect #To ensure every user is accounted for, create a new database record as soon as they sign in—if one doesn’t already exist. This not only keeps your records clean but also prepares you for future updates like credit transactions. Here’s a simple function to achieve that:\ndef ensure_user_in_database(conn: SupabaseConnection) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Ensure the current user exists in the database, creating a record if needed. Args: conn: Supabase connection \u0026#34;\u0026#34;\u0026#34; if not st.experimental_user.is_logged_in: return user_in_db = execute_query( conn.table(\u0026#34;users\u0026#34;).select(\u0026#34;email\u0026#34;).eq(\u0026#34;email\u0026#34;, st.experimental_user.email), ttl=0, ) if len(user_in_db.data) == 0: execute_query( conn.table(\u0026#34;users\u0026#34;).insert( {\u0026#34;email\u0026#34;: st.experimental_user.email, \u0026#34;credits\u0026#34;: NEW_USER_CREDITS} ), ttl=0, ) Since logging in involves clicking a button, it triggers a rerun from Streamlit. So, as long as we place this at the start of our app, this function will be called as soon as the user has logged in and before any logic that requires the user to exist in the database.\nNote that NEW_USER_CREDITS should be defined in your code with the value you wish to set as default credits for new users. This is where you can set how many (if any) free credits you want to give to your new users. Remember we store credits in cents (e.g. 50 credits is 50 cents).\nCaching and TTL #Caching is a handy way to boost performance by temporarily storing data so you don\u0026rsquo;t have to query the database on every request. In our case, imagine frequently checking a user’s credit balance—caching avoids repetitive queries. The TTL (Time-to-Live) is the duration the cached data stays valid before a fresh query is made. This balances performance with accuracy. In this tutorial, we will just set every ttl to 0, which guarantees accuracy at the cost of unoptimized performance. A good optimization strategy would be to set long ttls and clear the cache anytime we expect the database to have changed (a login, adding or removing credits).\nNext Steps #With a database in place, we can read and write credits for each of our users. Next, we’ll look at how to integrate Stripe.\nWant to see an example? SimplyPlot uses a credit system for monetisation - it writes Matplotlib code for you, so you can stop troubleshooting your plots. Get updates \u0026amp; insights! Subscribe ","date":"8 March 2025","permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/connecting-to-a-database/","section":"Blog Posts","summary":"Need to store user credits securely? In this post, we’ll show you how to hook your Streamlit app up to a database — with row-level security, secret-handling best practices, and a quick table setup walkthrough.","title":"Connecting To A Database"},{"content":" Ready to start charging for your app? In this post we will learn how to set up a pay-per-use system — from creating Stripe Checkout sessions to listening to webhooks. This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Why Do We Need Stripe? #If you want to charge users for your app, you need a payment processor — a service that handles credit card transactions, securely moves money, and ensures compliance with financial regulations. Stripe has become the default choice for many developers because it’s easy to integrate and widely supported. That’s why we’re using it here.\nWhat About LemonSqueezy, Polar\u0026hellip;? #Some other payment processors, such as LemonSqueezy and Polar, work differently — they act as Merchants of Record (MoR). This means they don’t just process payments; they also handle taxes, chargebacks, and compliance for you (in exchange for a bigger cut of your profits).\nWith Stripe, you\u0026rsquo;re responsible for these things yourself. If you want full control over your payments and customer relationships, Stripe is a good option. However, if dealing with VAT, sales tax, and regulations seems overwhelming, an MoR might be a better fit.\nRequirements #Before we get started, make sure you have:\nUser Authentication and a Database: If you haven\u0026rsquo;t done this yet, follow the first part of this blog for authentication and the second for databases. Stripe’s Python SDK: Install it with pip install stripe. Integrate Stripe Checkouts #Stripe operates in two modes:\nTest Mode / Sandboxes: Simulate transactions without real money, perfect for development and testing. Stripe recently transitioned from traditional test environments to \u0026ldquo;sandboxes,\u0026rdquo; allowing you to start testing without entering business details until you\u0026rsquo;re ready to go live. Live Mode: Handle real transactions with actual funds. Each mode comes with its own API keys, keeping testing data separate from live transactions.\nConfiguring Your Stripe Account #In the \u0026ldquo;Settings\u0026rdquo; menu, go to \u0026ldquo;Business \u0026gt; Branding \u0026gt; Checkout \u0026amp; Payment Links\u0026rdquo;. On the left, you can add your icon and logo, and adjust your brand colors.\nCalling The API #On the left sidebar, select \u0026ldquo;Home\u0026rdquo;, which will display your API Keys on the right hand side (or search for \u0026ldquo;API keys\u0026rdquo; in the search bar). Click to reveal your secret key and copy it to your .streamlit/secrets.toml file.\nMake sure you never publish your secrets, do not commit them to GitHub! Always include secrets.toml in your .gitignore file. Read more about secrets management here. Add the following section to your secrets.toml file:\n[stripe] API_KEY = \u0026#34;xxxx\u0026#34; SUCCESS_URL = \u0026#34;http://localhost:8501\u0026#34; Testing Your Stripe Setup #To test your Stripe setup, you can use the following Python code to create a checkout session that allows users to purchase credits. This script integrates with Stripe\u0026rsquo;s API to create a session where users can complete their payment.\ndef create_checkout_session(amount: float, user_email: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; Create a Stripe checkout session for purchasing credits. Args: amount: Dollar amount to charge (e.g., 5.00 means $5) user_email: Email of the current user Returns: str: URL for the checkout session \u0026#34;\u0026#34;\u0026#34; # Set the Stripe API key using the secrets stored in Streamlit stripe.api_key = st.secrets[\u0026#34;stripe\u0026#34;][\u0026#34;API_KEY\u0026#34;] # Create a checkout session with the specified parameters checkout_session = stripe.checkout.Session.create( customer_email=user_email, # Associate the session with the user\u0026#39;s email line_items=[ # Define the items being purchased { \u0026#34;price_data\u0026#34;: { \u0026#34;currency\u0026#34;: \u0026#34;usd\u0026#34;, # Currency for the payment \u0026#34;product_data\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Credits Purchase\u0026#34;, # Name of the item being purchased }, \u0026#34;unit_amount\u0026#34;: int(amount * 100), # Convert the amount to cents (Stripe expects cents) }, \u0026#34;quantity\u0026#34;: 1, } ], mode=\u0026#34;payment\u0026#34;, # This sets the checkout mode to a one-time payment success_url=st.secrets[\u0026#34;stripe\u0026#34;][\u0026#34;SUCCESS_URL\u0026#34;], # URL to redirect to after a successful payment ) # Return the URL where the user can complete their payment return checkout_session.url This function takes an amount (in dollars) and the user\u0026rsquo;s email to generate a Stripe checkout session. After creating the session, it returns a URL where the user can finalize the payment.\nYou can use this function in your app like this:\n# Allow users to choose the amount of credits they want to purchase amount = st.number_input( \u0026#34;Amount to add\u0026#34;, # Label for the input field min_value=1.00, # Minimum purchase amount max_value=10.00, # Maximum purchase amount value=3.00, # Default value step=0.5, # Step value for each increment (using the +/- buttons) format=\u0026#34;%.2f\u0026#34;, # Format the amount as currency help=\u0026#34;Enter an amount between \\\\$1 and \\\\$10\u0026#34;, # Help text for users ) # Generate the Stripe checkout session URL using the amount and user\u0026#39;s email checkout_url = create_checkout_session(amount, st.experimental_user.email) # Provide a link for the user to start the checkout process st.link_button(\u0026#34;Buy now\u0026#34;, checkout_url) This example allows users to enter the amount they wish to purchase (between $1 and $10). Once they select the amount, they can click the \u0026ldquo;Buy now\u0026rdquo; button, which directs them to the Stripe checkout page to complete their purchase.\nYou can test the checkout process using Stripe\u0026rsquo;s test cards. These test cards simulate various payment scenarios, allowing you to ensure everything works correctly before going live.\nThe Hard Part, Stripe Webhooks #What Are Stripe Webhooks, Why Do They Exist? #Stripe webhooks are user-defined HTTP callbacks that allow your application to receive real-time notifications about events occurring in your Stripe account. When specific actions happen — such as a successful payment — Stripe sends an HTTP POST request to a URL you configure, containing details about the event.\nBut why? The reason webhooks exist is to make sure your app stays in sync with Stripe. For example, after a user completes a payment, you might want to update their account or grant credits. But if you only rely on the success page URL to handle this, there’s a chance the user could close the browser or lose internet connection before your app completes the action.\nWebhooks let you handle payment events directly on your server, regardless of whether the user is still on the success page or not. This ensures your system processes payments accurately and consistently.\nGoing Serverless #So, we need to listen to webhooks. That means we need something running on a server. But here’s the catch: if we’re deploying on community cloud (yes we will), we can’t just run server code.\nHere are two options:\nDeploy elsewhere – Sure, you could set up a server with another provider to handle webhooks. But that brings its own set of headaches: managing servers, scaling, security, costs\u0026hellip; you get it. Use a serverless function – This is where serverless comes in. With a serverless function, you don’t need to manage servers at all. You just write the function, deploy it, and it runs when triggered (like when Stripe sends a webhook). It scales automatically, and you only pay for when it’s running. Super efficient! Okay, but what’s a serverless function exactly? Well, it\u0026rsquo;s a piece of code you\u0026rsquo;re giving to a cloud provider so you can run code without worrying about the infrastructure. You don’t have to set up or maintain a server. The cloud provider does all that work for you — they run your function, scale it when needed, and only charge you for the time your code runs.\nServerless functions are only serverless in the sense that you don\u0026rsquo;t have to deal with the server, but it does exist! Choosing a Provider #Now, which provider to choose? There are a lot of options: AWS Lambda, Google Cloud Functions, and others. AWS Lambda is popular, but it can be a bit much for simple use cases.\nBut what if I told you that you already have a provider? Supabase! Supabase offers edge functions. Don\u0026rsquo;t worry! It\u0026rsquo;s just a fancy name for a special kind of serverless functions, that live on servers all over the world to be closer to the users (on the edge of the network) and enable faster processing times. By using Supabase, we can easily integrate our code with our existing database. No need to jump between different services — it’s all in one place.\nWriting The Webhook Handler #So, we can run code on the cloud, but now we need the code! This part is an adapted version of Supabase\u0026rsquo;s official tutorial, go check it out if you want. First, let\u0026rsquo;s set up our supabase edge function:\nInstall the Supabase CLI Move to your project\u0026rsquo;s directory and create a new edge function with supabase functions new stripe-webhook This will create a supabase folder in your project, inside of which you will find functions/stripe-webhook/index.ts. This is where we will write the code we will put on the edge.\nFirst of all, we need to talk to Stripe and Supabase, so we import their libraries.\n// Import Stripe and Supabase\u0026#39;s createClient function. import Stripe from \u0026#39;https://esm.sh/stripe@14.25.0?target=denonext\u0026#39; import { createClient } from \u0026#39;jsr:@supabase/supabase-js@2\u0026#39; Here, we’re pulling in the Stripe library (from a CDN) and Supabase’s client. These imports let us call Stripe’s API and interact with our Supabase database later on.\nThen, we need to initialize Stripe with our API key.\n1 2 3 4 5 6 7 // Import Stripe and Supabase\u0026#39;s createClient function. import Stripe from \u0026#39;https://esm.sh/stripe@14.25.0?target=denonext\u0026#39; import { createClient } from \u0026#39;jsr:@supabase/supabase-js@2\u0026#39; const stripe = new Stripe(Deno.env.get(\u0026#39;STRIPE_API_KEY\u0026#39;) as string, { apiVersion: \u0026#39;2024-11-20\u0026#39; }); Here, we create a stripe instance using our API key (stored in an environment variable, which we will discuss later) and specify the API version.\nNow, we want to set up a server that listens for incoming webhooks from Stripe.\n1 2 3 4 5 6 7 8 9 10 11 // Import Stripe and Supabase\u0026#39;s createClient function. import Stripe from \u0026#39;\u0026lt;https://esm.sh/stripe@14.25.0?target=denonext\u0026gt;\u0026#39; import { createClient } from \u0026#39;jsr:@supabase/supabase-js@2\u0026#39; const stripe = new Stripe(Deno.env.get(\u0026#39;STRIPE_API_KEY\u0026#39;) as string, { apiVersion: \u0026#39;2024-11-20\u0026#39; }); Deno.serve(async (request) =\u0026gt; { // Our webhook handling code will go here. }); Using Deno’s built-in serve function, we set up an HTTP server. Every time Stripe sends a webhook, this function gets triggered with the incoming request.\nBefore processing the webhook, we need to confirm that the request is really from Stripe.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Import Stripe and Supabase\u0026#39;s createClient function. import Stripe from \u0026#39;https://esm.sh/stripe@14.25.0?target=denonext\u0026#39; import { createClient } from \u0026#39;jsr:@supabase/supabase-js@2\u0026#39; const stripe = new Stripe(Deno.env.get(\u0026#39;STRIPE_API_KEY\u0026#39;) as string, { apiVersion: \u0026#39;2024-11-20\u0026#39; }); const cryptoProvider = Stripe.createSubtleCryptoProvider(); Deno.serve(async (request) =\u0026gt; { // First step is to verify the event. The .text() method must be used as the // verification relies on the raw request body rather than the parsed JSON. const signature = request.headers.get(\u0026#39;Stripe-Signature\u0026#39;) const body = await request.text() let receivedEvent try { receivedEvent = await stripe.webhooks.constructEventAsync( body, signature!, Deno.env.get(\u0026#39;STRIPE_WEBHOOK_SIGNING_SECRET\u0026#39;)!, undefined, cryptoProvider ) } catch (err) { if (err instanceof Error) { return new Response(err.message, { status: 400 }) } return new Response(\u0026#39;Unknown error occurred\u0026#39;, { status: 400 }) } }); In this code:\nWe extract the Stripe-Signature from the request headers. We read the raw request body (using .text()) because verification needs the unaltered data. We call constructEventAsync with our body, signature, webhook secret (from env variables), and crypto provider. If verification fails, we catch the error and return a 400 response. Now that we’ve verified the webhook, we only want to act on events indicating a successful checkout.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // Import Stripe and Supabase\u0026#39;s createClient function. import Stripe from \u0026#39;https://esm.sh/stripe@14.25.0?target=denonext\u0026#39; import { createClient } from \u0026#39;jsr:@supabase/supabase-js@2\u0026#39; const stripe = new Stripe(Deno.env.get(\u0026#39;STRIPE_API_KEY\u0026#39;) as string, { apiVersion: \u0026#39;2024-11-20\u0026#39; }); const cryptoProvider = Stripe.createSubtleCryptoProvider(); Deno.serve(async (request) =\u0026gt; { // First step is to verify the event. The .text() method must be used as the // verification relies on the raw request body rather than the parsed JSON. const signature = request.headers.get(\u0026#39;Stripe-Signature\u0026#39;) const body = await request.text() let receivedEvent try { receivedEvent = await stripe.webhooks.constructEventAsync( body, signature!, Deno.env.get(\u0026#39;STRIPE_WEBHOOK_SIGNING_SECRET\u0026#39;)!, undefined, cryptoProvider ) } catch (err) { if (err instanceof Error) { return new Response(err.message, { status: 400 }) } return new Response(\u0026#39;Unknown error occurred\u0026#39;, { status: 400 }) } // Once the event has been verified, we can handle it based on its type. if (receivedEvent.type === \u0026#39;checkout.session.completed\u0026#39;) { const session = receivedEvent.data.object; const userEmail = session.customer_email; const amount = session.amount_total; /// Continue processing the payment } }); Here, we check if the event type is checkout.session.completed. If it is, we extract important details: the customer\u0026rsquo;s email and the payment amount. We’ll use these details to update the user\u0026rsquo;s credits.\nWe need to connect to our Supabase database so we can update the user\u0026rsquo;s credits, but first we must sign in.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // Import Stripe and Supabase\u0026#39;s createClient function. import Stripe from \u0026#39;https://esm.sh/stripe@14.25.0?target=denonext\u0026#39; import { createClient } from \u0026#39;jsr:@supabase/supabase-js@2\u0026#39; const stripe = new Stripe(Deno.env.get(\u0026#39;STRIPE_API_KEY\u0026#39;) as string, { apiVersion: \u0026#39;2024-11-20\u0026#39; }); const cryptoProvider = Stripe.createSubtleCryptoProvider(); Deno.serve(async (request) =\u0026gt; { // First step is to verify the event. The .text() method must be used as the // verification relies on the raw request body rather than the parsed JSON. const signature = request.headers.get(\u0026#39;Stripe-Signature\u0026#39;) const body = await request.text() let receivedEvent try { receivedEvent = await stripe.webhooks.constructEventAsync( body, signature!, Deno.env.get(\u0026#39;STRIPE_WEBHOOK_SIGNING_SECRET\u0026#39;)!, undefined, cryptoProvider ) } catch (err) { if (err instanceof Error) { return new Response(err.message, { status: 400 }) } return new Response(\u0026#39;Unknown error occurred\u0026#39;, { status: 400 }) } // Once the event has been verified, we can handle it based on its type. if (receivedEvent.type === \u0026#39;checkout.session.completed\u0026#39;) { const session = receivedEvent.data.object; const userEmail = session.customer_email; const amount = session.amount_total; const supabase = createClient(Deno.env.get(\u0026#39;SUPABASE_URL\u0026#39;)!, Deno.env.get(\u0026#39;SUPABASE_ANON_KEY\u0026#39;)!) try { // First, sign in with the correct credentials to see the data const { error: loginError } = await supabase.auth.signInWithPassword({ email: Deno.env.get(\u0026#39;EMAIL\u0026#39;)!, password: Deno.env.get(\u0026#39;PASSWORD\u0026#39;)!, }); if (loginError) { throw loginError; } // Continue with fetching and updating user data... } catch (error) { console.error(`Error updating user credits for user ${userEmail}:`, error); return new Response(\u0026#39;Failed to update user credits\u0026#39;, { status: 500 }); } } }); We create a Supabase client using our URL and anon key. Then, we sign in using our service account’s credentials (stored in our environment). If the sign-in fails, we log the error and return a 500 response, halting further processing. Now, we need to fetch the user’s current credits, add the amount from the Stripe session, and update the record.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 // Import Stripe and Supabase\u0026#39;s createClient function. import Stripe from \u0026#39;https://esm.sh/stripe@14.25.0?target=denonext\u0026#39; import { createClient } from \u0026#39;jsr:@supabase/supabase-js@2\u0026#39; const stripe = new Stripe(Deno.env.get(\u0026#39;STRIPE_API_KEY\u0026#39;) as string, { apiVersion: \u0026#39;2024-11-20\u0026#39; }); const cryptoProvider = Stripe.createSubtleCryptoProvider(); Deno.serve(async (request) =\u0026gt; { // First step is to verify the event. The .text() method must be used as the // verification relies on the raw request body rather than the parsed JSON. const signature = request.headers.get(\u0026#39;Stripe-Signature\u0026#39;) const body = await request.text() let receivedEvent try { receivedEvent = await stripe.webhooks.constructEventAsync( body, signature!, Deno.env.get(\u0026#39;STRIPE_WEBHOOK_SIGNING_SECRET\u0026#39;)!, undefined, cryptoProvider ) } catch (err) { if (err instanceof Error) { return new Response(err.message, { status: 400 }) } return new Response(\u0026#39;Unknown error occurred\u0026#39;, { status: 400 }) } // Once the event has been verified, we can handle it based on its type. if (receivedEvent.type === \u0026#39;checkout.session.completed\u0026#39;) { const session = receivedEvent.data.object; const userEmail = session.customer_email; const amount = session.amount_total; const supabase = createClient(Deno.env.get(\u0026#39;SUPABASE_URL\u0026#39;)!, Deno.env.get(\u0026#39;SUPABASE_ANON_KEY\u0026#39;)!) try { // First, sign in with the correct credentials to see the data const { error: loginError } = await supabase.auth.signInWithPassword({ email: Deno.env.get(\u0026#39;EMAIL\u0026#39;)!, password: Deno.env.get(\u0026#39;PASSWORD\u0026#39;)!, }); if (loginError) { throw loginError; } const { data: userData, error: fetchError } = await supabase .from(\u0026#39;users\u0026#39;) .select(\u0026#39;credits\u0026#39;) .eq(\u0026#39;email\u0026#39;, userEmail) .single(); if (fetchError) { throw fetchError; } const currentCredits = userData?.credits || 0; const newCredits = currentCredits + amount; // Finally, update with the new total const { error: updateError } = await supabase .from(\u0026#39;users\u0026#39;) .update({ credits: newCredits }) .eq(\u0026#39;email\u0026#39;, userEmail); if (updateError) { throw updateError; } console.log(`Updated credits for user ${userEmail} from ${currentCredits} to ${newCredits}`); } catch (error) { console.error(`Error updating user credits for user ${userEmail}:`, error); return new Response(\u0026#39;Failed to update user credits\u0026#39;, { status: 500 }); } } }); We query the users table to fetch the current credit balance for the user. We calculate the new total by adding the amount from the payment. We update the user’s record with the new credit balance. A log message confirms the update, which is useful for tracking and debugging. After processing the webhook, we need to let Stripe know everything went well.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // Import Stripe and Supabase\u0026#39;s createClient function. import Stripe from \u0026#39;https://esm.sh/stripe@14.25.0?target=denonext\u0026#39; import { createClient } from \u0026#39;jsr:@supabase/supabase-js@2\u0026#39; const stripe = new Stripe(Deno.env.get(\u0026#39;STRIPE_API_KEY\u0026#39;) as string, { apiVersion: \u0026#39;2024-11-20\u0026#39; }); const cryptoProvider = Stripe.createSubtleCryptoProvider(); Deno.serve(async (request) =\u0026gt; { // First step is to verify the event. The .text() method must be used as the // verification relies on the raw request body rather than the parsed JSON. const signature = request.headers.get(\u0026#39;Stripe-Signature\u0026#39;) const body = await request.text() let receivedEvent try { receivedEvent = await stripe.webhooks.constructEventAsync( body, signature!, Deno.env.get(\u0026#39;STRIPE_WEBHOOK_SIGNING_SECRET\u0026#39;)!, undefined, cryptoProvider ) } catch (err) { if (err instanceof Error) { return new Response(err.message, { status: 400 }) } return new Response(\u0026#39;Unknown error occurred\u0026#39;, { status: 400 }) } // Once the event has been verified, we can handle it based on its type. if (receivedEvent.type === \u0026#39;checkout.session.completed\u0026#39;) { const session = receivedEvent.data.object; const userEmail = session.customer_email; const amount = session.amount_total; const supabase = createClient(Deno.env.get(\u0026#39;SUPABASE_URL\u0026#39;)!, Deno.env.get(\u0026#39;SUPABASE_ANON_KEY\u0026#39;)!) try { // First, sign in with the correct credentials to see the data const { error: loginError } = await supabase.auth.signInWithPassword({ email: Deno.env.get(\u0026#39;EMAIL\u0026#39;)!, password: Deno.env.get(\u0026#39;PASSWORD\u0026#39;)!, }); if (loginError) { throw loginError; } const { data: userData, error: fetchError } = await supabase .from(\u0026#39;users\u0026#39;) .select(\u0026#39;credits\u0026#39;) .eq(\u0026#39;email\u0026#39;, userEmail) .single(); if (fetchError) { throw fetchError; } const currentCredits = userData?.credits || 0; const newCredits = currentCredits + amount; // Finally, update with the new total const { error: updateError } = await supabase .from(\u0026#39;users\u0026#39;) .update({ credits: newCredits }) .eq(\u0026#39;email\u0026#39;, userEmail); if (updateError) { throw updateError; } console.log(`Updated credits for user ${userEmail} from ${currentCredits} to ${newCredits}`); } catch (error) { console.error(`Error updating user credits for user ${userEmail}:`, error); return new Response(\u0026#39;Failed to update user credits\u0026#39;, { status: 500 }); } } return new Response(JSON.stringify({ ok: true }), { status: 200 }) }); If everything is processed without errors, we return a JSON response with { ok: true } and a 200 status code. This tells Stripe that we’ve handled the webhook successfully.\nDeploying The Webhook Handler # Install Docker\nSupabase Edge Functions run in a containerized environment, so you’ll need Docker installed on your machine. Download and follow the instructions from their website. Deploy the Webhook Function\nDo this by running supabase functions deploy --no-verify-jwt stripe-webhook. When prompted, select the correct Supabase project. The --no-verify-jwt flag ensures that the function runs without authentication, since Stripe doesn’t send a JWT token with its webhooks. Get the Endpoint URL\nGo to your Supabase dashbaord and select your project. In the left sidebar click \u0026ldquo;Edge Functions\u0026rdquo;. Here you should see the stripe-webhook function we just deployed, and an accompanying URL field, copy its contents. Register the Webhook in Stripe\nGo to your Stripe Dashboard. In the left sidebar, down at the bottom, click \u0026ldquo;Developers \u0026gt; Webhooks\u0026rdquo;. Click \u0026ldquo;Add destination\u0026rdquo;. Under \u0026ldquo;Events,\u0026rdquo; select checkout.session.completed, click \u0026ldquo;Continue\u0026rdquo;. For \u0026ldquo;Destination types,\u0026rdquo; select \u0026ldquo;Webhook endpoint\u0026rdquo;, click \u0026ldquo;Continue\u0026rdquo;. Under \u0026ldquo;Endpoint URL,\u0026rdquo; paste the previously copied URL from Supabase and click \u0026ldquo;Create destination\u0026rdquo;. Setup the Environment Variables\nStill in Stripe, get the \u0026ldquo;Signing secret\u0026rdquo; visible on the right-hand side when you select the event destination we just set up. Create a .env file in functions/stripe-webhook that should look like this: STRIPE_API_KEY=\u0026#34;xxxx\u0026#34; STRIPE_WEBHOOK_SIGNING_SECRET=\u0026#34;xxxx\u0026#34; # The email and password combo of the Supabase user you set up previously. # If you followed the previous guide, they should be present in your .streamlit/secrets.toml file EMAIL=\u0026#34;xxxx\u0026#34; PASSWORD=\u0026#34;xxxx\u0026#34; Add this file to .gitignore to prevent exposing secrets in your repo! Send this file to Supabase by running supabase secrets set --env-file ./supabase/functions/stripe-webhook/.env Testing Your Payment Workflow #Alright, time to make sure everything is working! We’ll check if the user’s credit balance updates after a successful payment.\nFirst, let’s get the user’s current balance from our database:\ndef get_user_credits(conn: SupabaseConnection) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34; Get the current user\u0026#39;s credit balance. Args: conn: Supabase connection Returns: int: User\u0026#39;s credit balance in cents \u0026#34;\u0026#34;\u0026#34; return execute_query( conn.table(\u0026#34;users\u0026#34;).select(\u0026#34;credits\u0026#34;).eq(\u0026#34;email\u0026#34;, st.experimental_user.email), ttl=None, ).data[0][\u0026#34;credits\u0026#34;] Now, let\u0026rsquo;s show the user their current balance in a nice, simple UI:\nst.metric( \u0026#34;Credit Balance\u0026#34;, f\u0026#34;${user_credits / 100:.2f}\u0026#34;, # Convert cents to dollars help=\u0026#34;Your credit balance will be consumed as you use the app.\u0026#34;, ) This displays the balance in dollars instead of cents, making it more readable.\nFinally, run a test payment using one of Stripe\u0026rsquo;s test cards, complete the checkout session and you should be automatically redirected to your Streamlit app, with the updated balance showing up!\nIf it doesn’t update, check your Supabase logs and Stripe dashboard for any webhook errors.\nNext Steps #Now that payments are working and credits update correctly, it\u0026rsquo;s time to put them to use! Next, we\u0026rsquo;ll connect to an LLM API and track usage, making sure credits are deducted as the user interacts with the model.\nWant to see an example? FastPrompt uses a credit system for monetisation - it generates high quality LLM system prompts from a simple description of inputs outputs. You can refine it with AI suggestions and iterate quickly. Get updates \u0026amp; insights! Subscribe ","date":"14 March 2025","permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/integrating-stripe-checkouts/","section":"Blog Posts","summary":"Ready to start charging for your app? In this post we will learn how to set up a pay-per-use system — from creating Stripe Checkout sessions to listening to webhooks.","title":"Integrating Stripe Checkouts"},{"content":" Draft Ready for your app to do something? In this post learn how to query an LLM API — including measuring costs and removing credits from users. This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Get updates \u0026amp; insights! Subscribe ","date":"1 January 0001","permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/calling-llm-apis/","section":"Blog Posts","summary":"Ready for your app to do something? In this post learn how to query an LLM API — including measuring costs and removing credits from users.","title":"Calling LLM APIs"},{"content":" Draft You’ve built something awesome — now it’s time to share it with the world! Learn the ins and outs of deploying your Streamlit app on Streamlit Cloud, it\u0026rsquo;s (almost) as simple as a single click. This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Get updates \u0026amp; insights! Subscribe ","date":"1 January 0001","permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/deploying-your-app/","section":"Blog Posts","summary":"You’ve built something awesome — now it’s time to share it with the world! Learn the ins and outs of deploying your Streamlit app on Streamlit Cloud, it\u0026rsquo;s (almost) as simple as a single click.","title":"Deploying Your App"},{"content":"","date":null,"permalink":"/blog/","section":"","summary":"","title":""},{"content":"Get updates \u0026amp; insights!\nSubscribe ","date":null,"permalink":"/blog/posts/","section":"Blog Posts","summary":"","title":"Blog Posts"},{"content":"Ready to turn your Streamlit app into a pay-per-use service? In this series, we\u0026rsquo;ll build a credit-based payment system that’s perfect for generative AI apps. You\u0026rsquo;ll learn how to set up user logins, connect to a database, and integrate Stripe payments in Streamlit — all while creating a smooth credit-based pricing system. We\u0026rsquo;ll also dive into LLM API integration and wrap it up with tips on Streamlit production deployment. It’s a straightforward, step-by-step guide to launching your pay-per-use Streamlit app in no time.\nWant to see an example? SimplyPlot uses a credit system for monetisation - it writes Matplotlib code for you, so you can stop troubleshooting your plots. Get updates \u0026amp; insights! Subscribe ","date":null,"permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/","section":"Blog Posts","summary":"Build a credit-based payment system in Streamlit for generative AI apps — from user logins to production deployment.","title":"Build a Credit Payment System in Streamlit for Gen AI Apps"},{"content":"","date":null,"permalink":"/blog/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/blog/tags/","section":"Tags","summary":"","title":"Tags"}]