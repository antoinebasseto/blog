[{"content":" User authentication is the first step in building any app that needs to track who\u0026rsquo;s who — like one with user credits 👀 — and with Streamlit\u0026rsquo;s new native authentication features, it\u0026rsquo;s easier than ever! This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Why User Authentication? #So, why bother with user authentication when all we want is a credit system? Well, every user needs their own balance. We need to be able to track who paid for what, and who\u0026rsquo;s using how much, and for that we first need to know who\u0026rsquo;s who. Luckily, Streamlit has made this process super easy with its native authentication features introduced in version 1.42. This means setting up secure logins will be a breeze!\nPrerequisites #Before we jump in, make sure you have the following ready:\nStreamlit version \u0026gt;= 1.42.0: The native authentication features are available from this version onward. Check your version with streamlit --version. Authlib \u0026gt;= 1.3.2: This library is required to use Streamlit\u0026rsquo;s native authentication features. Install it with pip install Authlib. Once you’ve got these sorted, you’re ready to set up authentication!\nSetting Up Native Authentication in Streamlit #Streamlit now offers a straightforward way to handle user logins. You can read more from the official docs here, but we\u0026rsquo;ll break down the process step by step.\nConfigure Your Identity Provider #Identity providers handle the heavy lifting of user authentication and security — so you don\u0026rsquo;t have to manage passwords or other sensitive details yourself. Streamlit supports any provider using OpenID Connect (OIDC), but in this tutorial we will use Google Identity. Why? Well, it\u0026rsquo;s straightforward to set up and widely used. However, this does mean users will need a Google account to sign up for our app. If that’s a problem, you can explore other providers, such as Auth0.\nLet\u0026rsquo;s walk through the process of setting up Google as your identity provider:\nSign up for Google Cloud\nFirst, you\u0026rsquo;ll need a Google Cloud account. If you don\u0026rsquo;t already have one, go to the Google Cloud Console and sign up with your Google account.\nCreate a New Project\nLook for the project dropdown near the top of the page Click \u0026ldquo;New Project\u0026rdquo; Give your project a name that\u0026rsquo;s relevant to your Streamlit app Click \u0026ldquo;Create\u0026rdquo; Wait for Google to set up your new project (it might take a minute) Make sure your new project is selected in the project dropdown Set Up OAuth Credentials\nNow we need to create OAuth credentials that your Streamlit app will use to authenticate users:\nIn the left sidebar, navigate to \u0026ldquo;APIs \u0026amp; Services \u0026gt; Credentials\u0026rdquo; Click the \u0026ldquo;Create Credentials\u0026rdquo; button at the top of the page Select \u0026ldquo;OAuth client ID\u0026rdquo; from the dropdown menu When prompted to configure the consent screen first, click \u0026ldquo;Configure Consent Screen\u0026rdquo; and fill in the required information: App name: The name users will see when signing in User support email: Your email address Select \u0026ldquo;External\u0026rdquo; as the user type (unless you\u0026rsquo;re building an internal app for a Google Workspace organization) Developer contact information: Your email address Under \u0026ldquo;Google Auth Platform / Audience\u0026rdquo;, go to \u0026ldquo;Test Users\u0026rdquo; and add the Google account you will use for testing. Under \u0026ldquo;Google Auth Platform / Data access\u0026rdquo;, click \u0026ldquo;Add or remove scopes\u0026rdquo; and select the scope .../auth/userinfo.email, which means we will have access to our users\u0026rsquo; email address, then click \u0026ldquo;Update\u0026rdquo;. Now return to \u0026ldquo;Credentials\u0026rdquo; and click \u0026ldquo;Create Credentials \u0026gt; OAuth client ID\u0026rdquo; again For \u0026ldquo;Application type,\u0026rdquo; select \u0026ldquo;Web application\u0026rdquo; Fill in the required information: Name of your OAuth client, I named mine web_client_projectname. Under \u0026ldquo;Authorized JavaScript origins\u0026rdquo;, add http://localhost:8501 Under \u0026ldquo;Authorized redirect URIs\u0026rdquo;, add http://localhost:8501/oauth2callback Once we deploy our app, we will have to add our live domain to the authorized origins and redirect URIs. Click \u0026ldquo;Create Client\u0026rdquo; Copy paste your client secret and client ID, we will need them soon! You can find them again under \u0026ldquo;Google Auth Platform / Clients\u0026rdquo; and then clicking on the client you just created. The consent screen is initially in \u0026ldquo;Testing\u0026rdquo; mode with restrictions on the number of users. For a production app, you would need to go through Google\u0026rsquo;s verification process to publish it, but testing mode is sufficient for development or internal apps. We\u0026rsquo;ll worry about that when we try to deploy our app.\nConfigure Your Secrets #Now that we\u0026rsquo;re all set up on Google\u0026rsquo;s side, we need to let our Streamlit app know! To use native authentication, Streamlit expects some information in the .streamlit/secrets.toml file. Remember those client secret and client id? This is where we use them.\nMake sure never to publish your secrets (e.g., avoid committing them to GitHub). Always include secrets.toml in your .gitignore file. Read more about secrets management here. Your secrets.toml file should look like this:\n[auth] redirect_uri = \u0026#34;http://localhost:8501/oauth2callback\u0026#34; cookie_secret = \u0026#34;a-long-string-of-random-characters-you-generated\u0026#34; # You can use https://www.random.org/strings/ [auth.google] client_id = \u0026#34;xxxx\u0026#34; client_secret = \u0026#34;xxxx\u0026#34; server_metadata_url = \u0026#34;https://accounts.google.com/.well-known/openid-configuration\u0026#34; Implement the Login Flow #Next, let’s implement the login flow in your Streamlit app. We’ll use Streamlit’s native auth functions: st.login, st.logout, and st.experimental_user to manage user sessions.\nA simple example would be:\nimport streamlit as st with st.sidebar: if not st.experimental_user.is_logged_in: st.button(\u0026#34;Log in\u0026#34;, on_click=st.login, args=(\u0026#34;google\u0026#34;)) st.stop() # Stop further execution if user is not logged in. st.button(\u0026#34;Log out\u0026#34;, on_click=st.logout, args=(\u0026#34;google\u0026#34;)) # Paid features come here (after st.stop()) Testing Your Authentication Setup #After implementing the login functionality, it’s time to test it out. Run your app with streamlit run your-app.py and make sure you can log in, log out and st.experimental_user contains the expected information — you can try st.write(st.experimental_user). Remember to log in with the Google account you set as a test account during set up.\nNext Steps #With user authentication in place, we can associate an email address with each user\u0026rsquo;s credit balance. Next, we’ll look at how to connect to a database.\nWant to see an example? SimplyPlot uses a credit system for monetisation - it writes Matplotlib code for you, so you can stop troubleshooting your plots. ","date":"7 March 2025","permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/setting-up-user-login/","section":"Blog Posts","summary":"User authentication is the first step in building any app that needs to track who\u0026rsquo;s who — like one with user credits 👀 — and with Streamlit\u0026rsquo;s new native authentication features, it\u0026rsquo;s easier than ever!","title":"Setting Up User Login"},{"content":" Need to store user credits securely? In this post, we’ll show you how to hook your Streamlit app up to a database — with row-level security, secret-handling best practices, and a quick table setup walkthrough. This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Why Do We Need A Database? #We need a database to keep track of user credit balances reliably. Whether adding or deducting credits, the data needs to stay consistent and accessible. Streamlit\u0026rsquo;s session_state won’t work for this, as it resets every time the app reloads. Therefore, we need a proper database to store and manage credits.\nWhich Database Should I Choose? #There are a lot of options out there, and there isn’t a one-size-fits-all solution. The ideal database depends on your specific needs—ease of setup, scalability and the available free tier are all key factors.\nIf your application only needs to store structured data like user information and credits, a relational (SQL) database is typically the best choice due to its strong consistency and structured querying capabilities. However, if your app requires flexibility (e.g., dynamic or hierarchical data structures, unstructured metadata, or document-based storage), a NoSQL database might be a better fit. Also, if you need to store large files, consider pairing your database with a dedicated file storage solution (e.g., Supabase Storage, Firebase Storage, or AWS S3). Below is a comparison of popular options:\nDatabase Type Free Tier Connector? Supabase recommended PostgreSQL Unlimited API requests, up to 50,000 monthly active users, 500 MB database size, 5 GB bandwidth, and 1 GB file storage. source SQLite Cloud SQLite 1 GB storage, up to 0.5 vCPUs, 0.5 GB RAM and 30 concurrent connections. source Firebase Firestore NoSQL Only default database, 1 GiB storage, 50000 reads / day, 20000 writes / day, 20000 deletes / day, 10 GiB data transfer / month. source MongoDB Atlas NoSQL 512 MB storage, shared RAM and vCPU. source Streamlit offers step-by-step guides to show how to connect to most of these (and others).\nFor this project, we are going to use Supabase. It offers a generous free tier, is easy to set up, and integrates seamlessly with Streamlit. We will also leverage their edge function features when integrating Stripe.\nRequirements #Before we begin, make sure you have:\nUser Login Set Up: If you haven\u0026rsquo;t done this yet, follow the first part of this series. Database Connector Installed: Install it with pip install st-supabase-connection. Connecting To A Database #Configure Your Supabase Project # Sign Up and Create a Project: Visit Supabase and sign up for a free account. Click “Create new project” and fill in: Project Name. Database Password: Choose a strong password. Region: Select the region closest to your users. Click \u0026ldquo;Create new project\u0026rdquo;. Create Your Table: In the left sidebar, click Table Editor. Click Create a new table and fill in the following: Name: Use users (or any name you prefer—just update your code accordingly). Description: Optional. Enable Row Level Security (RLS): Keep this checked. Edit Columns to include: id: Type int8 and set as the primary key. created_at: Type timestamptz with a default value of now(). email: Type text. Click the gear icon, uncheck \u0026ldquo;Is Nullable\u0026rdquo; and check \u0026ldquo;Is Unique\u0026rdquo;. credits: Type int4 (we will be storing credits as cents, the max value of an int4 number is 2147483647 i.e. a lot of money). Click the gear icon, uncheck \u0026ldquo;Is Nullable\u0026rdquo;, and set the default value to 0 (we will set a default value for new user in the code in case you do want to give new users some free credits). Click Save. Get Your Project Credentials: In the left sidebar, click Project overview. Scroll down to find your Project URL and API Key. You’ll need these soon. Set Up RLS Policies: In the left sidebar, click Authentication, then select Policies. Click Create policy and choose the template Enable insert for authenticated users only, and click Save policy. Next, select the template Enable read access for all users: Rename it to Enable read access for authenticated users only. Set the target role to authenticated. Click Save policy. Next, select again the template Enable insert for authenticated users only: Rename it to Enable update access for authenticated users only. Set the operation type to Update. Click Save policy. Still under Authentication, click Users in the left sidebar. Click Add user \u0026gt; Create a new user, enter an email address and a password of your choice, ensure auto confirm user is checked, then click create user. Keep these credentials handy for your connection. Configure Your Secrets #You know all this information I told you to keep handy? Well, your .streamlit/secrets.toml file is where you should put it!\nMake sure you never publish your secrets, do not commit them to GitHub! Always include secrets.toml in your .gitignore file. Read more about secrets management here. Add the following section to your secrets.toml file:\n[connections.supabase] SUPABASE_URL = \u0026#34;xxxx\u0026#34; SUPABASE_KEY = \u0026#34;xxxx\u0026#34; EMAIL_ADDRESS = \u0026#34;xxxx\u0026#34; PASSWORD = \u0026#34;xxxx\u0026#34; Connect With Your Streamlit App #Now, let\u0026rsquo;s set up the connection to the Supabase database. The code below establishes and caches a connection, ensuring that you can interact with your database securely.\n@st.cache_resource(show_spinner=False) def get_db_connection() -\u0026gt; SupabaseConnection: \u0026#34;\u0026#34;\u0026#34; Establish and cache a connection to the Supabase database. Returns: SupabaseConnection: Authenticated connection to Supabase \u0026#34;\u0026#34;\u0026#34; conn = st.connection(\u0026#34;supabase\u0026#34;, type=SupabaseConnection) conn.auth.sign_in_with_password( { \u0026#34;email\u0026#34;: st.secrets[\u0026#34;connections\u0026#34;][\u0026#34;supabase\u0026#34;][\u0026#34;EMAIL_ADDRESS\u0026#34;], \u0026#34;password\u0026#34;: st.secrets[\u0026#34;connections\u0026#34;][\u0026#34;supabase\u0026#34;][\u0026#34;PASSWORD\u0026#34;], } ) return conn Create Users As They Connect #To ensure every user is accounted for, create a new database record as soon as they sign in—if one doesn’t already exist. This not only keeps your records clean but also prepares you for future updates like credit transactions. Here’s a simple function to achieve that:\ndef ensure_user_in_database(conn: SupabaseConnection) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Ensure the current user exists in the database, creating a record if needed. Args: conn: Supabase connection \u0026#34;\u0026#34;\u0026#34; if not st.experimental_user.is_logged_in: return user_in_db = execute_query( conn.table(\u0026#34;users\u0026#34;).select(\u0026#34;email\u0026#34;).eq(\u0026#34;email\u0026#34;, st.experimental_user.email), ttl=0, ) if len(user_in_db.data) == 0: execute_query( conn.table(\u0026#34;users\u0026#34;).insert( {\u0026#34;email\u0026#34;: st.experimental_user.email, \u0026#34;credits\u0026#34;: NEW_USER_CREDITS} ), ttl=0, ) Since logging in involves clicking a button, it triggers a rerun from Streamlit. So, as long as we place this at the start of our app, this function will be called as soon as the user has logged in and before any logic that requires the user to exist in the database.\nNote that NEW_USER_CREDITS should be defined in your code with the value you wish to set as default credits for new users. This is where you can set how many (if any) free credits you want to give to your new users. Remember we store credits in cents (e.g. 50 credits is 50 cents).\nCaching and TTL #Caching is a handy way to boost performance by temporarily storing data so you don\u0026rsquo;t have to query the database on every request. In our case, imagine frequently checking a user’s credit balance—caching avoids repetitive queries. The TTL (Time-to-Live) is the duration the cached data stays valid before a fresh query is made. This balances performance with accuracy. In this tutorial, we will just set every ttl to 0, which guarantees accuracy at the cost of unoptimized performance. A good optimization strategy would be to set long ttls and clear the cache anytime we expect the database to have changed (a login, adding or removing credits).\nNext Steps #With a database in place, we can read and write credits for each of our users. Next, we’ll look at how to integrate Stripe.\nWant to see an example? SimplyPlot uses a credit system for monetisation - it writes Matplotlib code for you, so you can stop troubleshooting your plots. ","date":"8 March 2025","permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/connecting-to-a-database/","section":"Blog Posts","summary":"Need to store user credits securely? In this post, we’ll show you how to hook your Streamlit app up to a database — with row-level security, secret-handling best practices, and a quick table setup walkthrough.","title":"Connecting To A Database"},{"content":" Draft Ready to start charging for your app? In this post we will learn how to set up a pay-per-use system — from creating Stripe Checkout sessions to listening to webhooks. This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. ","date":"1 January 0001","permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/integrating-stripe-checkouts/","section":"Blog Posts","summary":"Ready to start charging for your app? In this post we will learn how to set up a pay-per-use system — from creating Stripe Checkout sessions to listening to webhooks.","title":"Integrating Stripe Checkouts"},{"content":" Draft Ready for your app to do something? In this post learn how to query an LLM API — including measuring costs and removing credits from users. This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. ","date":"1 January 0001","permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/calling-llm-apis/","section":"Blog Posts","summary":"Ready for your app to do something? In this post learn how to query an LLM API — including measuring costs and removing credits from users.","title":"Calling LLM APIs"},{"content":" Draft You’ve built something awesome — now it’s time to share it with the world! Learn the ins and outs of deploying your Streamlit app on Streamlit Cloud, it\u0026rsquo;s (almost) as simple as a single click. This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. ","date":"1 January 0001","permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/deploying-your-app/","section":"Blog Posts","summary":"You’ve built something awesome — now it’s time to share it with the world! Learn the ins and outs of deploying your Streamlit app on Streamlit Cloud, it\u0026rsquo;s (almost) as simple as a single click.","title":"Deploying Your App"},{"content":"","date":null,"permalink":"/blog/","section":"","summary":"","title":""},{"content":"","date":null,"permalink":"/blog/posts/","section":"Blog Posts","summary":"","title":"Blog Posts"},{"content":"Ready to turn your Streamlit app into a pay-per-use service? In this series, we\u0026rsquo;ll build a credit-based payment system that’s perfect for generative AI apps. You\u0026rsquo;ll learn how to set up user logins, connect to a database, and integrate Stripe payments in Streamlit — all while creating a smooth credit-based pricing system. We\u0026rsquo;ll also dive into LLM API integration and wrap it up with tips on Streamlit production deployment. It’s a straightforward, step-by-step guide to launching your pay-per-use Streamlit app in no time.\nWant to see an example? SimplyPlot uses a credit system for monetisation - it writes Matplotlib code for you, so you can stop troubleshooting your plots. ","date":null,"permalink":"/blog/posts/credit-based-payment-system-streamlit-generative-ai/","section":"Blog Posts","summary":"Build a credit-based payment system in Streamlit for generative AI apps — from user logins to production deployment.","title":"Build a Credit Payment System in Streamlit for Gen AI Apps"},{"content":" Stop the hassle with Matplotlib – let AI handle it Having to spend hours troubleshooting your plots? Simply describe what you need, get the Matplotlib code instantly, and refine it in real-time with your AI assistant.\nTry it now!\n","date":"8 February 2025","permalink":"/blog/posts/introducing-simplyplot/","section":"Blog Posts","summary":"Stop the hassle with Matplotlib – let AI handle it","title":"Introducing SimplyPlot — Your AI Matplotlib assistant"},{"content":"","date":null,"permalink":"/blog/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/blog/tags/","section":"Tags","summary":"","title":"Tags"}]