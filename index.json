[{"content":" User authentication is the first step to building any app that needs to know who\u0026rsquo;s who — like one with user credits 👀 — and with Streamlit\u0026rsquo;s new native authentication features, it\u0026rsquo;s easier than ever! This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Why User Authentication? #So, why bother with user authentication when all we want is a credit system? Well, every user needs their own balance. We need to be able to track who paid for what, and who\u0026rsquo;s using how much, and for that we first need to know who\u0026rsquo;s who. Luckily, Streamlit has made this process super easy with its native authentication features introduced in version 1.42. This means setting up secure logins will be a breeze!\nPrerequisites #Before we jump in, make sure you have the following ready:\nStreamlit version \u0026gt;= 1.42.0: The native authentication features are available from this version onward. Check your version with streamlit --version. Authlib \u0026gt;= 1.3.2: This library is required to use Streamlit\u0026rsquo;s native authentication feautures. Install it with pip install Authlib. Once you’ve got these sorted, you’re ready to set up authentication!\nSetting Up Native Authentication in Streamlit #Streamlit now offers a straightforward way to handle user logins. You can read more from the official docs here, but we\u0026rsquo;ll break down the process step by step.\nConfigure Your Identity Provider #Identity providers handle the heavy lifting of user authentication and security — so you don\u0026rsquo;t have to manage passwords or other sensitive details yourself. Streamlit supports any provider using OpenID Connect (OIDC) (I am not sure what it is either), but in this tutorial we will use Google Identity. Why? Well, it\u0026rsquo;s straightforward to set up and widely used. But yes, it does mean people will need a Google account to sign up to our app, if that is a problem for you, you can look into other providers, such as Auth0.\nLet\u0026rsquo;s walk through the process of setting up Google as your identity provider:\nSign up for Google Cloud\nFirst, you\u0026rsquo;ll need a Google Cloud account. If you don\u0026rsquo;t already have one, go to the Google Cloud Console and sign up with your Google account.\nCreate a New Project\nLook for the project dropdown near the top of the page Click \u0026ldquo;New Project\u0026rdquo; Give your project a name that\u0026rsquo;s relevant to your Streamlit app Click \u0026ldquo;Create\u0026rdquo; Wait for Google to set up your new project (it might take a minute) Make sure your new project is selected in the project dropdown Set Up OAuth Credentials\nNow we need to create OAuth credentials that your Streamlit app will use to authenticate users:\nIn the left sidebar, navigate to \u0026ldquo;APIs \u0026amp; Services \u0026gt; Credentials\u0026rdquo; Click the \u0026ldquo;Create Credentials\u0026rdquo; button at the top of the page Select \u0026ldquo;OAuth client ID\u0026rdquo; from the dropdown menu When prompted to configure the consent screen first, click \u0026ldquo;Configure Consent Screen\u0026rdquo; and fill in the required information: App name: The name users will see when signing in User support email: Your email address Select \u0026ldquo;External\u0026rdquo; as the user type (unless you\u0026rsquo;re building an internal app for a Google Workspace organization) Developer contact information: Your email address Under \u0026ldquo;Google Auth Platform / Audience\u0026rdquo;, go to \u0026ldquo;Test Users\u0026rdquo; and add the google account you will use for testing. Under \u0026ldquo;Google Auth Platform / Data access\u0026rdquo;, click \u0026ldquo;Add or remove scopes\u0026rdquo; and select the scope .../auth/userinfo.email, which means we will have access to our users\u0026rsquo; email address, then click \u0026ldquo;Update\u0026rdquo;. Now return to \u0026ldquo;Credentials\u0026rdquo; and click \u0026ldquo;Create Credentials \u0026gt; OAuth client ID\u0026rdquo; again For \u0026ldquo;Application type,\u0026rdquo; select \u0026ldquo;Web application\u0026rdquo; Fill in the required information: Name of your oauth client, I named mine web_client_projectname. Under \u0026ldquo;Authorized JavaScript origins\u0026rdquo;, add http://localhost:8501 Under \u0026ldquo;Authorized redirect URIs\u0026rdquo;, add http://localhost:8501/oauth2callback Once we deploy our app, we will have to add our live domain the authorized origins and redirect URIs. Click \u0026ldquo;Create Client\u0026rdquo; Copy paste your client secret and client ID, we will need them soon! You can find them again under \u0026ldquo;Google Auth Platform / Clients\u0026rdquo; and then clicking on the client you just created. The consent screen is initially in \u0026ldquo;Testing\u0026rdquo; mode with restrictions on the number of users. For a production app, you would need to go through Google\u0026rsquo;s verification process to publish it, but testing mode is sufficient for development or internal apps. We\u0026rsquo;ll worry about that when we try to deploy our app.\nConfigure Your Secrets #Now that we\u0026rsquo;re all set up on Google\u0026rsquo;s side, we need to let our Streamlit app know! To use native authentication, Streamlit expects some information in the secrets.toml file. Remember those client secret and client id? This is where we use them.\nMake sure you never publish your secrets (e.g. do not commit them to GitHub). Always include secrets.toml in your .gitignore file. Read more about secrets management here. Your secrets.toml file should look like this:\n[auth] redirect_uri = \u0026#34;http://localhost:8501/oauth2callback\u0026#34; cookie_secret = \u0026#34;a-long-string-of-random-characters-you-generated\u0026#34; # You can use https://www.random.org/strings/ [auth.google] client_id = \u0026#34;xxxx\u0026#34; client_secret = \u0026#34;xxxx\u0026#34; server_metadata_url = \u0026#34;https://accounts.google.com/.well-known/openid-configuration\u0026#34; Implement the Login Flow #Next, let’s implement the login flow in your Streamlit app. We’ll use Streamlit’s native auth functions: st.login, st.logout, and st.experimental_user to manage user sessions.\nA simple example would be:\nimport streamlit as st with st.sidebar: if not st.experimental_user.is_logged_in: st.button(\u0026#34;Log in\u0026#34;, on_click=st.login, args=(\u0026#34;google\u0026#34;)) st.stop() st.button(\u0026#34;Log out\u0026#34;, on_click=st.logout, args=(\u0026#34;google\u0026#34;)) # Paid features come here (after st.stop()) Testing Your Authentication Setup #After implementing the login functionality, it’s time to test it out. Run your app with streamlit run your-app.py and make sure you can log in, log out and st.experimental_user contains the expected information — you can try st.write(st.experimental_user). Remember to log in with the Google account you set as a test account during set up.\nNext Steps #With user authentication in place, we can put a name email address to people\u0026rsquo;s faces credit balance system. Next, we’ll look at how to connect to a database.\nWant to see an example? SimplyPlot uses a credit system for monetisation - it writes Matplotlib code for you, so you can stop troubleshooting your plots. ","date":"28 February 2025","permalink":"/blog/posts/streamlit-ai-credits/setting-up-user-login/","section":"","summary":"User authentication is the first step to building any app that needs to know who\u0026rsquo;s who — like one with user credits 👀 — and with Streamlit\u0026rsquo;s new native authentication features, it\u0026rsquo;s easier than ever!","title":"Setting Up User Login"},{"content":" Need to store user credits securely? In this post, we’ll show you how to hook your Streamlit app up to a database—with row-level security, secret-handling best practices, and a quick table setup walkthrough. This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Why Do We Need A Database? #Databases are the backbone of any dynamic application. In our case, we need to store and manage the credit balances of our users efficiently. Whether you’re updating credits after a transaction or querying the current balance, a database provides the reliability and performance necessary to keep everything in sync.\nWhich Database Should I Choose? #There are a lot of options out there, and most would work just fine. For this project, I’ve chosen Supabase. It offers a generous free tier, is easy to set up, and integrates seamlessly with Streamlit. The decision ultimately comes down to deployment needs and the flexibility Supabase offers for modern apps.\nComparison + about supabase free tier (table)\nRequirements #add login\nBefore you start, install the necessary package with pip install st-supabase-connection.\nConnecting To A Database #Configuring Your Supabase Project # Sign up to Supabase and create a free account. Create a new project by filling out the required information: project name database password region (closest to your users) Click \u0026ldquo;Create new project\u0026rdquo; In the left sidebar, click \u0026ldquo;Table Editor\u0026rdquo;, click \u0026ldquo;Create a new table\u0026rdquo; and fill out the required information: Name: the name of the table, we will use users, if you decide to use something else just make sure to adpat the code examples accordingly Description: optional Keep \u0026ldquo;Enable Row Level Security (RLS)\u0026rdquo; checked. Edit columns so you have the following: id, int8, set as primary key created_at, timestamptz, with default value now() email, text, click the gear icon, uncheck \u0026ldquo;Is Nullable\u0026rdquo; and check \u0026ldquo;Is Unique\u0026rdquo; credits, int4 (max value is 2147483647, i.e. more than $21 million because we will store cents), click the gear icon, uncheck \u0026ldquo;Is Nullable\u0026rdquo;, set 0 as the default value Click \u0026ldquo;Save\u0026rdquo; In the left sidebar, click \u0026ldquo;Project overview\u0026rdquo;, scroll down a bit, this is where you can find the Project URL and API Key, you will need them soon. RLS Policies\nIn the left sidebar, click \u0026ldquo;Authentication\u0026rdquo;, select \u0026ldquo;Policies\u0026rdquo; if it\u0026rsquo;s not already selected, and click \u0026ldquo;Create policy\u0026rdquo;. Create one policies from the templates \u0026ldquo;Enable insert for authenticated users only\u0026rdquo; Click on the policy template \u0026ldquo;Enable read access for all users\u0026rdquo;, rename it \u0026ldquo;Enable read access for authenticated users only\u0026rdquo;, select authenticated for target roles, click on \u0026ldquo;Save policy\u0026rdquo;. Enable update policy Still in \u0026ldquo;Authentication\u0026rdquo;, click on \u0026ldquo;Users\u0026rdquo; in the left sidebar. These are the Supabase users, not your app users, they are used to determine who has the right to which policy with RLS. Click on \u0026ldquo;Add user \u0026gt; Create a new user\u0026rdquo;, put in an email address and a password of your choice, leave \u0026ldquo;auto confirm user\u0026rdquo; checked on and click \u0026ldquo;create user\u0026rdquo; Keep your email address and password available, you will need them soon. Sign Up and Create a Project: Visit Supabase and sign up for a free account. Click “Create new project” and fill in: Project Name: Pick something memorable. Database Password: Choose a strong password. Region: Select the region closest to your users. Click \u0026ldquo;Create new project\u0026rdquo;. Create Your Table: In the left sidebar, click Table Editor. Click Create a new table and fill in the following: Name: Use users (or any name you prefer—just update your code accordingly). Description: Optional. Enable Row Level Security (RLS): Keep this checked. Edit Columns to include: id: Type int8 and set as the primary key. created_at: Type timestamptz with a default value of now(). email: Type text. Click the gear icon, uncheck \u0026ldquo;Is Nullable\u0026rdquo; and check \u0026ldquo;Is Unique\u0026rdquo;. credits: Type int4 (max value 2147483647, which is more than enough since we store cents). Click the gear icon, uncheck \u0026ldquo;Is Nullable\u0026rdquo;, and set the default value to 0. Click Save. Get Your Project Credentials: In the left sidebar, click Project overview. Scroll down to find your Project URL and API Key. You’ll need these soon. Set Up RLS Policies: In the left sidebar, click Authentication, then select Policies. Click Create policy and choose the template Enable insert for authenticated users only. Next, select the template Enable read access for all users, rename it to Enable read access for authenticated users only, set the target role to authenticated, and click Save policy. Still under Authentication, click Users in the left sidebar. Click Add user \u0026gt; Create a new user, enter an email address and a password of your choice, ensure auto confirm user is checked, then click create user. Keep these credentials handy for your connection.\nConnecting To Your Database #In your secrets.toml file, add the following section:\n[connections.supabase] SUPABASE_URL = \u0026#34;xxxx\u0026#34; SUPABASE_KEY = \u0026#34;xxxx\u0026#34; EMAIL_ADDRESS = \u0026#34;xxxx\u0026#34; PASSWORD = \u0026#34;xxxx\u0026#34; Make sure you never publish your secrets, do not commit them to GitHub! Always include secrets.toml in your .gitignore file. Read more about secrets management here. 1 2 3 4 5 6 7 8 9 10 11 import streamlit as st from st_supabase_connection import SupabaseConnection # Initialize connection. conn = st.connection(\u0026#34;supabase\u0026#34;,type=SupabaseConnection) conn.auth.sign_in_with_password( { \u0026#34;email\u0026#34;: st.secrets[\u0026#34;connections\u0026#34;][\u0026#34;supabase\u0026#34;][\u0026#34;EMAIL_ADDRESS\u0026#34;], \u0026#34;password\u0026#34;: st.secrets[\u0026#34;connections\u0026#34;][\u0026#34;supabase\u0026#34;][\u0026#34;PASSWORD\u0026#34;], } ) Explain caching and ttl.\nCreate users as they connect #Testing Your Database Setup #Next Steps #","date":"3 March 2025","permalink":"/blog/posts/streamlit-ai-credits/connecting-to-a-database/","section":"","summary":"Need to store user credits securely? In this post, we’ll show you how to hook your Streamlit app up to a database—with row-level security, secret-handling best practices, and a quick table setup walkthrough.","title":"Connecting To A Database"},{"content":" This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Why Do We Need Stripe? #What About LemonSqueezy, Polar\u0026hellip;? #Requirements #add login + database\npip install stripe\ntest mode vs. production mode as an alert\nIntegrate Stripe Checkouts #Configuring Your Stripe Account # \u0026ldquo;Settings \u0026gt; Payment methods\u0026rdquo;, deactivate buy now pay later \u0026ldquo;Setting \u0026gt; Business \u0026gt; Branding \u0026gt; Checkout \u0026amp; Payment links\u0026rdquo;, on the left add icon and logo, change your brand colors Calling The API #secrets.toml\nAPI_KEY = \u0026#34;xxxx\u0026#34; SUCCESS_URL = \u0026#34;http://localhost:8501\u0026#34; Testing Your Stripe Setup #test mode vs. production mode\nThe Hard Part, Stripe Webhooks #What Are Stripe Webhooks, Why Do They Exist? #Going Serverless - Choosing A Provider #Writing The Webhook Handler # Install the supabase CLI\nCreate a new function with supabase functions new stripe-webhook\nUse the following code for the function\n// Import via bare specifier thanks to the import_map.json file. import Stripe from \u0026#39;https://esm.sh/stripe@14.25.0?target=denonext\u0026#39; import { createClient } from \u0026#39;jsr:@supabase/supabase-js@2\u0026#39; const stripe = new Stripe(Deno.env.get(\u0026#39;STRIPE_API_KEY\u0026#39;) as string, { // This is needed to use the Fetch API rather than relying on the Node http // package. apiVersion: \u0026#39;2024-11-20\u0026#39; }) // This is needed in order to use the Web Crypto API in Deno. const cryptoProvider = Stripe.createSubtleCryptoProvider() Deno.serve(async (request) =\u0026gt; { const signature = request.headers.get(\u0026#39;Stripe-Signature\u0026#39;) // First step is to verify the event. The .text() method must be used as the // verification relies on the raw request body rather than the parsed JSON. const body = await request.text() let receivedEvent try { receivedEvent = await stripe.webhooks.constructEventAsync( body, signature!, Deno.env.get(\u0026#39;STRIPE_WEBHOOK_SIGNING_SECRET\u0026#39;)!, undefined, cryptoProvider ) } catch (err) { if (err instanceof Error) { return new Response(err.message, { status: 400 }) } return new Response(\u0026#39;Unknown error occurred\u0026#39;, { status: 400 }) } // Once the event has been verified, we can handle it based on its type. if (receivedEvent.type === \u0026#39;checkout.session.completed\u0026#39;) { const session = receivedEvent.data.object; const userEmail = session.customer_email; const amount = session.amount_total; const supabase = createClient(Deno.env.get(\u0026#39;SUPABASE_URL\u0026#39;)!, Deno.env.get(\u0026#39;SUPABASE_ANON_KEY\u0026#39;)!) try { // First, sign in with the correct credentials to see the data const { error: loginError } = await supabase.auth.signInWithPassword({ email: Deno.env.get(\u0026#39;EMAIL\u0026#39;)!, password: Deno.env.get(\u0026#39;PASSWORD\u0026#39;)!, }); if (loginError) { throw loginError; } // Then, get the current credits of the user const { data: userData, error: fetchError } = await supabase .from(\u0026#39;users\u0026#39;) .select(\u0026#39;credits\u0026#39;) .eq(\u0026#39;email\u0026#39;, userEmail) .single(); if (fetchError) { throw fetchError; } const currentCredits = userData?.credits || 0; const newCredits = currentCredits + amount; // Finally, update with the new total const { error: updateError } = await supabase .from(\u0026#39;users\u0026#39;) .update({ credits: newCredits }) .eq(\u0026#39;email\u0026#39;, userEmail); if (updateError) { throw updateError; } console.log(`Updated credits for user ${userEmail} from ${currentCredits} to ${newCredits}`); } catch (error) { console.error(`Error updating user credits for user ${userEmail}:`, error); return new Response(\u0026#39;Failed to update user credits\u0026#39;, { status: 500 }); } } return new Response(JSON.stringify({ ok: true }), { status: 200 }) }); Explain code\nInstall Docker\nRun supabase functions deploy --no-verify-jwt stripe-webhook, choose the correct project\nGo to Supabase, copy the endpoint URL\nGo to Stripe\nIn the left sidebar, click \u0026ldquo;Developpers \u0026gt; Webhooks\u0026rdquo; at the bottom.\nClick \u0026ldquo;Add destination\u0026rdquo; Keep as is, for event select checkout.session.completed Select webhook endpoint Paste the endpoint URL Click \u0026ldquo;Create destination\u0026rdquo; Copy the \u0026ldquo;Signing secret\u0026rdquo; on the right-hand side\nCreate a .env file in functions/stripe-webhook, MAKE SURE TO ADD IT TO GITIGNORE\nAdd your stripe api key and webhook signing secret:\nSTRIPE_API_KEY=\u0026#34;xxxx\u0026#34; STRIPE_WEBHOOK_SIGNING_SECRET=\u0026#34;xxxx\u0026#34; EMAIL=\u0026#34;xxxx\u0026#34; PASSWORD=\u0026#34;xxxx\u0026#34; Give supabase your secrets supabase secrets set --env-file ./supabase/functions/stripe-webhook/.env Connecting To The Database #Testing Your Payment Workflow #Next Steps #","date":"6 March 2025","permalink":"/blog/posts/streamlit-ai-credits/integrating-stripe-checkouts/","section":"","summary":"","title":"Integrating Stripe Checkouts"},{"content":" This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Why Are We Talking About This #how to calculate costs.\nRequirements #Choosing LLM Provider #Calling an LLM API #Setting Up Your Account #Making API Requests #Consuming Credits Properly #Testing Your Consumption Workflow #Next Steps #","date":"1 January 0001","permalink":"/blog/posts/streamlit-ai-credits/calling-llm-apis/","section":"","summary":"","title":"Calling LLM APIs"},{"content":" You’ve built something awesome — now it’s time to share it with the world! Learn the ins and outs of deploying your Streamlit app on Streamlit Cloud, it\u0026rsquo;s (almost) as simple as a single click. This post is part of a series to learn how to build and deploy a Streamlit app with a credit system, covering authentication, payments with Stripe, databases, and more. Why Do We Need To Deploy Our App? #Which Deployment Option Should I Choose? #streamlit cloud\nRequirements #pip freeze \u0026gt; requirements.txt\nPreparing Your App For Deployment #Configuring Your Deployment Environment #Need to change:\nGoogle auth\nstatus authorized uris Go to google cloud platform\nLeft sidebar, click \u0026ldquo;APIs and Service \u0026gt; OAuth Consent Screen\u0026rdquo;\nClick \u0026ldquo;Audience\u0026rdquo;\nClick \u0026ldquo;Publish App\u0026rdquo;\nStripe\napi keys redirect url create restricted key create webhook Supabase nothing!\nsecrets.toml\nauth redirect_uri stripe api_key and success_url update webhook signing secret serve new .env file to supabase\nDeploying Your App # build requirements.txt git push everything click deploy copy paste secrets.toml Testing Your Deployment #Next Steps #","date":"1 January 0001","permalink":"/blog/posts/streamlit-ai-credits/deploying-your-app/","section":"","summary":"You’ve built something awesome — now it’s time to share it with the world! Learn the ins and outs of deploying your Streamlit app on Streamlit Cloud, it\u0026rsquo;s (almost) as simple as a single click.","title":"Deploying Your App"},{"content":"","date":null,"permalink":"/blog/","section":"","summary":"","title":""},{"content":"","date":null,"permalink":"/blog/posts/","section":"","summary":"","title":""},{"content":"","date":null,"permalink":"/blog/posts/streamlit-ai-credits/","section":"","summary":"","title":"Streamlit AI Credits"},{"content":"","date":null,"permalink":"/blog/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/blog/tags/","section":"Tags","summary":"","title":"Tags"}]